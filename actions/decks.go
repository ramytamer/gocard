package actions

import (
	"errors"
	"fmt"
	"gocard/models"
	"net/http"
	"strings"

	"github.com/gobuffalo/buffalo"
	"github.com/gobuffalo/pop/v5"
	"github.com/gobuffalo/pop/v5/slices"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (Deck)
// DB Table: Plural (decks)
// Resource: Plural (Decks)
// Path: Plural (/decks)
// View Template Folder: Plural (/templates/decks/)

// DecksResource is the resource for the Deck model
type DecksResource struct {
	buffalo.Resource
}

// Show gets the data for one Deck. This function is mapped to
// the path GET /decks/{deck_id}
func (v DecksResource) Show(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return fmt.Errorf("no transaction found")
	}

	// Allocate an empty Deck
	deck := &models.Deck{Data: slices.Map{}}

	// To find the Deck the parameter deck_id is used.
	if err := tx.Find(deck, c.Param("deck_id")); err != nil {
		return c.Error(http.StatusNotFound, errors.New(fmt.Sprintf("No Deck Found with id: (%v)", c.Param("deck_id"))))
	}

	return c.Render(200, r.JSON(renderShowDeck(*deck)))
}

// Create adds a Deck to the DB. This function is mapped to the
// path POST /decks
func (v DecksResource) Create(c buffalo.Context) error {
	// Allocate an empty Deck
	deck := &models.Deck{Data: slices.Map{}}

	if err := c.Bind(deck); err != nil {
		return err
	}

	convertCodesToCards(deck)

	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return fmt.Errorf("no transaction found")
	}

	// Validate the data from the html form
	verrs, err := tx.ValidateAndCreate(deck)
	if err != nil {
		return err
	}

	if verrs.HasAny() {
		return c.Render(http.StatusUnprocessableEntity, r.JSON(verrs))
	}

	return c.Render(http.StatusCreated, r.JSON(renderCreateDeck(*deck)))
}

// Update changes a Deck in the DB. This function is mapped to
// the path PUT /decks/{deck_id}
func (v DecksResource) Draw(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return fmt.Errorf("no transaction found")
	}

	// Allocate an empty Deck
	deck := &models.Deck{Data: slices.Map{}}

	if err := tx.Find(deck, c.Param("deck_id")); err != nil {
		return c.Error(http.StatusNotFound, errors.New(fmt.Sprintf("No Deck Found with id: (%v)", c.Param("deck_id"))))
	}

	// Bind Deck to the html form elements
	if err := c.Bind(deck); err != nil {
		return err
	}

	cards := deck.Data["cards"].([]interface{})

	if deck.Count <= 0 || deck.Count > 52 || deck.Count > len(cards) {
		return c.Error(http.StatusUnprocessableEntity, errors.New(fmt.Sprintf("Invalid count number: (%v)", deck.Count)))
	}

	if deck.Shuffled {
		cards = shuffleCards(cards)
	}

	drawnCards := cards[0:deck.Count]
	remainingCards := cards[deck.Count:]

	data := map[string]interface{}{"cards": remainingCards}
	m := slices.Map{}
	m.Scan(data)

	deck.Data = data
	err := tx.Save(deck)
	if err != nil {
		return c.Render(http.StatusUnprocessableEntity, r.JSON(err))
	}

	return c.Render(http.StatusOK, r.JSON(renderDrawnCards(drawnCards)))
}

func generateAndAssignFullDeck(deck *models.Deck) {
	cards := []models.Card{}

	suits := []int{models.CLUBS, models.DIAMOND, models.HEARTS, models.SPADES}

	for _, suit := range suits {
		for i := 1; i <= 13; i++ {
			cards = append(cards, models.Card{Value: i, Suit: suit})
		}
	}

	deckCards := make([]interface{}, len(cards))
	for i, card := range cards {
		deckCards[i] = card.ToMap()
	}

	data := map[string]interface{}{"cards": deckCards}
	m := slices.Map{}
	m.Scan(data)

	deck.Data = data
}

func convertCodesToCards(deck *models.Deck) {
	codes := strings.Split(deck.PartialCards, ",")
	cards := make([]models.CardMap, 0)
	for _, code := range codes {
		card, err := models.MakeCardFromCode(code)
		if err == nil {
			cards = append(cards, card.ToMap())
		}
	}

	if len(cards) != 0 {
		deckCards := make([]interface{}, len(cards))
		for i, card := range cards {
			deckCards[i] = card
		}

		data := map[string]interface{}{"cards": deckCards}
		m := slices.Map{}
		m.Scan(data)

		deck.Data = data
	} else {
		generateAndAssignFullDeck(deck)
	}
}
